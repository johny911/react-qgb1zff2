/* eslint-env serviceworker */
/* eslint-disable no-restricted-globals */

// --- Workbox imports ---
import { clientsClaim } from 'workbox-core';
import {
  precacheAndRoute,
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
} from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst, CacheFirst } from 'workbox-strategies';

// Take control ASAP
self.skipWaiting();
clientsClaim();

/**
 * Precache the assets generated by your build.
 * This array is injected by Workbox at build time.
 */
precacheAndRoute(self.__WB_MANIFEST || []);
cleanupOutdatedCaches();

/**
 * ⚠️ IMPORTANT: Never cache / intercept Supabase requests.
 * We let them go straight to the network so auth & role fetches are always fresh.
 *
 * This covers REST, Auth, Storage, Functions for both supabase.co and supabase.in.
 */
self.addEventListener('fetch', (event) => {
  const url = event.request.url;

  // If it's any call to Supabase, bypass the SW (Network only).
  if (/(^https?:\/\/).*\.supabase\.(co|in)/i.test(url)) {
    event.respondWith(fetch(event.request));
    return; // Do not let Workbox routes handle it
  }
});

/**
 * App-shell style navigation routing:
 *  - Serve index.html for navigation requests (client-side routing)
 *  - Skip anything that clearly looks like a static asset (has an extension)
 *  - Do NOT special-case allowlist to only "/" (we want all routes to work)
 */
registerRoute(
  new NavigationRoute(
    createHandlerBoundToURL('/index.html'),
    {
      // Deny-list requests that look like asset files (e.g. .png, .js, .css, etc.)
      denylist: [
        /\.[^/]+$/i,      // any path with an extension
        /\/api\//i,       // your own API paths (if any)
      ],
      // No allowlist: match all navigations by default (better SPA behavior)
    }
  )
);

/**
 * Static resources (JS/CSS/Workers): Stale-While-Revalidate for snappy loads.
 */
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

/**
 * Images: Cache First (fine for logos/icons). You can add expiration rules if desired.
 */
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    matchOptions: { ignoreSearch: true },
  })
);

/**
 * Optional: Network First for same-origin GET /api/* responses
 * (Keep / remove depending on your own API usage.)
 */
registerRoute(
  ({ url, request }) =>
    request.method === 'GET' &&
    url.origin === self.location.origin &&
    url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api',
    networkTimeoutSeconds: 5,
  })
);

/**
 * Support “Update available” flows from your UI:
 * postMessage({ type: 'SKIP_WAITING' }) to activate the new SW immediately.
 */
self.addEventListener('message', (event) => {
  if (event?.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});